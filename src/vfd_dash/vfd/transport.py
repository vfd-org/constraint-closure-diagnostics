"""
VFD Transport Structure and Interaction Algebra.

Transport modes are the fundamental objects from which internal primes arise.
A transport mode (m, +/-) represents propagation through m cells.

The interaction algebra A is generated by shift S and local operators L.
Internal primes are irreducible elements of A with positive transport length.
"""

import numpy as np
from numpy.typing import NDArray
from typing import List, Tuple, Optional, Set
from dataclasses import dataclass, field
from enum import Enum

from .canonical import VFDSpace, TorsionOperator, ShiftOperator, TORSION_ORDER


class Direction(Enum):
    """Transport direction."""
    FORWARD = "+"
    BACKWARD = "-"


@dataclass(frozen=True)
class TransportMode:
    """
    A transport mode in the VFD framework.

    Transport modes (m, d) represent propagation:
    - m: transport length (positive integer)
    - d: direction (+ or -)

    Torsion class is m mod 12, signed by direction.
    """
    length: int
    direction: Direction

    def __post_init__(self):
        if self.length < 0:
            raise ValueError("Transport length must be non-negative")

    @property
    def torsion_class(self) -> int:
        """Torsion class: m mod 12 with sign from direction."""
        sign = 1 if self.direction == Direction.FORWARD else -1
        return (sign * self.length) % TORSION_ORDER

    @property
    def signed_length(self) -> int:
        """Signed transport length."""
        sign = 1 if self.direction == Direction.FORWARD else -1
        return sign * self.length

    def compose(self, other: "TransportMode") -> "TransportMode":
        """
        Compose two transport modes.

        Composition adds signed lengths and determines resulting direction.
        """
        total = self.signed_length + other.signed_length

        if total >= 0:
            return TransportMode(abs(total), Direction.FORWARD)
        else:
            return TransportMode(abs(total), Direction.BACKWARD)

    def inverse(self) -> "TransportMode":
        """Return inverse transport mode."""
        new_dir = Direction.BACKWARD if self.direction == Direction.FORWARD else Direction.FORWARD
        return TransportMode(self.length, new_dir)

    def __str__(self) -> str:
        return f"({self.length}, {self.direction.value})"

    def __repr__(self) -> str:
        return f"TransportMode({self.length}, {self.direction})"


@dataclass
class Factorization:
    """A factorization of a transport mode into smaller modes."""
    original: TransportMode
    factors: List[TransportMode]
    is_trivial: bool = False  # True if factors = [original]

    def __post_init__(self):
        # Verify factorization is valid
        if len(self.factors) == 0:
            self.is_trivial = True
            return

        result = self.factors[0]
        for f in self.factors[1:]:
            result = result.compose(f)

        if result != self.original:
            raise ValueError(f"Invalid factorization: {self.factors} does not compose to {self.original}")

        self.is_trivial = (len(self.factors) == 1 and self.factors[0] == self.original)

    def __str__(self) -> str:
        return " * ".join(str(f) for f in self.factors)


@dataclass
class TransportAlgebra:
    """
    The interaction algebra generated by transport modes.

    This algebra is noncommutative due to torsion twist effects.
    Internal primes are irreducible elements with positive length.
    """
    space: VFDSpace
    T: TorsionOperator
    S: ShiftOperator

    # Cache for computed properties
    _irreducibles: Set[TransportMode] = field(default_factory=set)
    _factorizations: dict = field(default_factory=dict)

    def get_mode(self, length: int, direction: str = "+") -> TransportMode:
        """Create a transport mode."""
        d = Direction.FORWARD if direction == "+" else Direction.BACKWARD
        return TransportMode(length, d)

    def is_irreducible(self, mode: TransportMode, max_factor: Optional[int] = None) -> Tuple[bool, Optional[Factorization]]:
        """
        Check if a transport mode is irreducible.

        A mode is irreducible if it cannot be written as a nontrivial
        composition of smaller modes.

        Args:
            mode: Transport mode to check
            max_factor: Maximum factor length to search

        Returns:
            Tuple of (is_irreducible, counterexample_factorization)
        """
        if mode.length <= 1:
            return True, None

        if max_factor is None:
            max_factor = mode.length - 1

        # Try to find nontrivial factorizations
        target = mode.signed_length

        for m1 in range(1, min(max_factor, mode.length) + 1):
            for d1 in [Direction.FORWARD, Direction.BACKWARD]:
                f1 = TransportMode(m1, d1)
                remainder = target - f1.signed_length

                if remainder == 0:
                    continue  # Would be trivial

                m2 = abs(remainder)
                d2 = Direction.FORWARD if remainder > 0 else Direction.BACKWARD

                if m2 > 0 and m2 < mode.length:
                    f2 = TransportMode(m2, d2)
                    factorization = Factorization(mode, [f1, f2])
                    return False, factorization

        return True, None

    def find_all_factorizations(
        self,
        mode: TransportMode,
        max_factors: int = 3,
        max_factor_length: Optional[int] = None
    ) -> List[Factorization]:
        """
        Find all factorizations of a mode up to a given complexity.

        Args:
            mode: Mode to factorize
            max_factors: Maximum number of factors
            max_factor_length: Maximum length of individual factors

        Returns:
            List of distinct factorizations
        """
        if max_factor_length is None:
            max_factor_length = mode.length - 1

        factorizations = []
        target = mode.signed_length

        # Two-factor factorizations
        if max_factors >= 2:
            for m1 in range(1, min(max_factor_length, mode.length) + 1):
                for d1 in [Direction.FORWARD, Direction.BACKWARD]:
                    f1 = TransportMode(m1, d1)
                    remainder = target - f1.signed_length

                    if remainder == 0:
                        continue

                    m2 = abs(remainder)
                    d2 = Direction.FORWARD if remainder > 0 else Direction.BACKWARD

                    if 0 < m2 <= max_factor_length:
                        f2 = TransportMode(m2, d2)
                        try:
                            fact = Factorization(mode, [f1, f2])
                            if not fact.is_trivial:
                                factorizations.append(fact)
                        except ValueError:
                            pass

        # Three-factor factorizations
        if max_factors >= 3:
            for m1 in range(1, min(max_factor_length, mode.length) + 1):
                for d1 in [Direction.FORWARD, Direction.BACKWARD]:
                    f1 = TransportMode(m1, d1)
                    rem1 = target - f1.signed_length

                    for m2 in range(1, min(max_factor_length, abs(rem1)) + 1):
                        for d2 in [Direction.FORWARD, Direction.BACKWARD]:
                            f2 = TransportMode(m2, d2)
                            rem2 = rem1 - f2.signed_length

                            if rem2 == 0:
                                continue

                            m3 = abs(rem2)
                            d3 = Direction.FORWARD if rem2 > 0 else Direction.BACKWARD

                            if 0 < m3 <= max_factor_length:
                                f3 = TransportMode(m3, d3)
                                try:
                                    fact = Factorization(mode, [f1, f2, f3])
                                    if not fact.is_trivial:
                                        factorizations.append(fact)
                                except ValueError:
                                    pass

        return factorizations

    def get_irreducibles_up_to(self, max_length: int) -> List[TransportMode]:
        """
        Get all irreducible modes up to given length.

        Args:
            max_length: Maximum transport length

        Returns:
            List of irreducible modes
        """
        irreducibles = []

        for m in range(1, max_length + 1):
            for d in [Direction.FORWARD, Direction.BACKWARD]:
                mode = TransportMode(m, d)
                is_irr, _ = self.is_irreducible(mode)
                if is_irr:
                    irreducibles.append(mode)

        return irreducibles

    def demonstrate_non_ufd(self, max_search: int = 20) -> Optional[Tuple[TransportMode, List[Factorization]]]:
        """
        Find an example demonstrating non-UFD structure.

        Looks for a mode with multiple inequivalent factorizations.

        Args:
            max_search: Maximum mode length to search

        Returns:
            Tuple of (mode, inequivalent_factorizations) or None
        """
        for m in range(4, max_search + 1):
            for d in [Direction.FORWARD, Direction.BACKWARD]:
                mode = TransportMode(m, d)
                facts = self.find_all_factorizations(mode, max_factors=3)

                # Check for inequivalent factorizations
                # (different multisets of factor lengths)
                seen_signatures = set()
                inequivalent = []

                for fact in facts:
                    sig = tuple(sorted([f.signed_length for f in fact.factors]))
                    if sig not in seen_signatures:
                        seen_signatures.add(sig)
                        inequivalent.append(fact)

                if len(inequivalent) >= 2:
                    return mode, inequivalent

        return None
